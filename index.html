<!DOCTYPE html>
<html>
<head>
<title>OpenMap</title>
<meta charset="utf-8" />
<meta name="theme-color" content="#369">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="HandheldFriendly" content="true">
<meta name="mobile-web-app-capable" content="yes"> 
<link rel="shortcut icon" type="image/webp" size="144x144" href="./onemap.webp"> 

<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
<script src="./js/geomap.js"></script>
<script src="./js/mini.js"></script>
<link rel="stylesheet" href="./css/openmap.css">
<style>
    body {margin: 0;}
    pre#info {padding:0.5em;}
.polygon-label {color:red;}
/* Styl dla etykiety tekstowej poligonu */
.polygon-label-top-left {
    background:#93c4fb; 
    opacity:0.8;  
    white-space: nowrap; 
}
table td, table th {
    border: 1px solid gray;
    padding: 0.25em;
}
td:last-child {text-align: right;}
.btn {background:#ddd;}
.leaflet-right {width:150px;}
.leaflet-touch .leaflet-control-layers, .leaflet-touch .leaflet-bar{border: none;}
.leaflet-bottom.leaflet-right{width:initial;}
</style>
</head>
<body>

    <div id="map"></div>

    <pre id="info"></pre>

    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    
<script>

let   startLat = 53.17;
const deltaLat =  0.07;
const startLon = 14.2;
const deltaLon =  0.09;
let countFake  =  0;
let nodeCount=0
let daneJson={}
let fakeGeo=0;

const convert2Dat=(meshtNODE)=>{


    let arr = [];
    let notRole={};
    let inneCNT=0;
    let noGEO=0;
    for (id in meshtNODE){
        let nod = meshtNODE[id];
        //if (!nod.latitude)  {delete meshtNODE[id]; continue;}
        //if (!nod.longitude) {delete meshtNODE[id]; continue;}
        
        //console.log(id,nod);
        let obj = {}
        obj.id=id;
        let bgcolor = "#"+id.slice(-6);
        let txcolor = checkBrightness(bgcolor);
        let txcstyl = styleBrightness(bgcolor);
        obj.bgcolor = bgcolor;
        obj.txcolor = txcolor;
        obj.lat = parseInt(nod.latitude   || 0)/10000000;
        obj.lon = parseInt(nod.longitude  || 0)/10000000;
        //console.log(obj.lat,obj.lon)
        if (obj.lat===0 || obj.lon===0) noGEO++;
                            let geo=[];
                            geo[0] = obj.lat;
                            geo[1] = obj.lon;
                            //console.log(geo)
                            let km = ok(geoKM(geo));
                            obj.km = km;
        obj.opis = nod.shortname;
        obj.long = nod.longname;
        obj.kategoria = roles[nod.role] || "Inne";
        if (obj.kategoria==="Inne") inneCNT++;
                if (!roles[nod.role]) {
                    //console.log("---",id,nod.shortname,"role=",roles[nod.role],nod)
                    notRole[id] = nod.shortname
                }
            let time = nod.timestamp*1000;
            obj.time = (new Date(time)).toLocaleString('pl-PL');
            let tnow = (new Date()).getTime();
            let doba = (tnow-time)/(1000*3600*24);
            let godzin = ok((tnow-time)/(1000*3600));
  
            obj.doba = Math.round(doba)+"day";
            obj.data_dodania = godzin;
            
            //console.log("nd=",nod.doba,obj.time)
        
        obj.role = nod.role;
        obj.snr  = nod.snr;
        obj.hop  = nod.hop+"/"+nod.hops;
        obj.szczegolowy_opis = nod.longname;
        obj.info = `<span>Hop:${nod.hop}, Role:${roles[nod.role]}</span>`;
        //if (nod.shortname==="Mila") continue;
        //if (nod.shortname==="BG_M") continue;
        //console.log(bgcolor,txcolor)
        arr.push(obj)
    }
    console.log("inneCNT=",inneCNT,"noGEO=",noGEO)
    nodeCount = Object.keys(meshtNODE).length;
    return arr;
}


const hexToRgb=(hex) =>{
        let result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? {
            r: parseInt(result[1], 16),
            g: parseInt(result[2], 16),
            b: parseInt(result[3], 16)
        } : null;
    }    
    const checkBrightness=(hex)=>{
        if (hex==="#?") return "#006"
        let color = hexToRgb(hex);
        if (!color) return "#000"
        const brightness = Math.round(((parseInt(color.r) * 299) +   (parseInt(color.g) * 587) + (parseInt(color.b) * 114)) / 1000)
        if(brightness < 150){return("rgb(255,255,255)")} 
        else {return("rgb(0,0,0)")}
    }   
    const styleBrightness=(hex)=>{
        if (hex==="#?") return "#006"
        let color = hexToRgb(hex);
        if (!color) return "#000"
        const brightness = Math.round(((parseInt(color.r) * 299) +   (parseInt(color.g) * 587) + (parseInt(color.b) * 114)) / 1000)
        if(brightness < 150){return("white")} 
        else {return("black")}
    }   
  
const fakePosition=()=>{
    countFake++;
    if (countFake>10) {
        countFake = 1;
        startLat-=deltaLat;
    }
	return [startLat,startLon+okk(deltaLon*countFake)];
}    
const showOrNot=(flag=true)=>{
    let aless = document.querySelectorAll('input[type=checkbox]');

    [...aless].forEach((input,i)=>{
        input.checked = flag;        
        const kategoria = input.getAttribute('data-kategoria');
        //console.log(i,kategoria);
        const grupa = kategorieGrupy[kategoria];
        
        if (grupa){
            //console.log(i,grupa);
            if (flag) {map.addLayer(grupa);$("#licznik").textContent     = nodeCount;}
            else      {map.removeLayer(grupa); $("#licznik").textContent = 0;}
        }
    });
    //policzWidocznePunkty();
}

const showSearch=(action=null)=>{
    console.log(action)
}

const pallete=["#FF0000","#008800","#0000FF","#FF00FF","#000000","#800000","#00FFFF","#808000","#008000","#800080","#008080","#000080","#808080","#C0C0C0","#FFA500","#FFFF00"];
const roles = ["CLIENT","CLIENT_MUTE","ROUTER","ROUTER_CLIENT","REPEATER","TRACKER","SENSOR","TAK","CLIENT_HIDDEN","LOST_AND_FOUND","TAK_TRACKER","ROUTER_LATE","CLIENT_BASE"];
let kategorieGrupy = {};
let map = null;

const punktyURL = "./zapis/mesh_nodes.json";
const infoURL   = "./zapis/mesh_info.json";

const runRUN=async()=>{
	return await asyncFetchJson(punktyURL); 
}
const runINFO=async()=>{
	return await asyncFetchJson(infoURL); 
}


// dom ready domready async *****************************************************************
// dom ready domready async *****************************************************************
// dom ready domready async *****************************************************************
document.addEventListener("DOMContentLoaded",async (event)=>{ 
    const wszystkieMarkery = [];
	let meshtNODE0 = await runRUN();
	//console.log("meshtNODE111=",meshtNODE0);
    //const showOrNot_=()=>{showOrNot()}

            //let meshtNODE0 = JSON.parse(str_meshtNODE);
            //console.log(0,Object.keys(meshtNODE0).length);
            let meshtNODE = {}
            
                    for (id in meshtNODE0){
                        let nod = meshtNODE0[id];
                        //console.log(0,id,nod.shortname, nod.latitude,nod.latitude,nod.role)
                                //if (nod.latitude  === undefined) {delete meshtNODE0[id];  continue;}
                                //if (nod.longitude === undefined) {delete meshtNODE0[id];  continue;}
                                if (nod.latitude===undefined || nod.longitude===undefined || nod.latitude===0 || nod.longitude===0) {
                                    //delete meshtNODE0[id];  continue;
                                    let geo = fakePosition();
                                    nod.latitude  = geo[0]*10000000;
                                    nod.longitude = geo[1]*10000000;
                                    fakeGeo++
                                    //console.log("fakePosition=",geo)
                                    //console.log("nod====",nod)
                                }
                                
                            /*if (id==="!b03d116c") {
                                console.log(!nod.shortname,"uuuuuuuuu=",nod)
                            }*/
                        
                            if (nod.shortname === "xxx" || !nod.shortname) {
                                nod.shortname = id.substr(id.length - 4);
                                nod.longname  = id;
                            }
                            meshtNODE[id] = nod;
                    }
                    console.log("fakeGeo=",fakeGeo)
                    //$(".fakeGeo").textContent = fakeGeo;
                    //console.log(1,Object.keys(meshtNODE).length);
                    for (id in meshtNODE){
                        let nod = meshtNODE[id];
                        //console.log(1,id,nod.shortname, nod.latitude,nod.latitude,nod.role)
                    }
            let kategorie=[];
            let objKat = {};
            let arrKat=[];
            for (let id in meshtNODE){
                let role = meshtNODE[id].role;
                //if (role===2) console.log("2 ROUTER=",id,meshtNODE[id].shortname)
                //if (role===5) console.log("5 tracker=",id,meshtNODE[id].shortname)
                //if (role===11) console.log("11 ROUTER_LATE=",id,meshtNODE[id].shortname,role)
                if (role!="undefine" && role!=null) {
                    //kategorie.push(role)
                    if (!objKat[role]) objKat[role]=0;
                    objKat[role]++;
                }
            }
            //console.log(objKat);
            //arrKat = Object.keys(objKat);

            for(let v in objKat){
                
                let c = objKat[v]
                arrKat.push(c)
                let name = roles[parseInt(v)];
                kategorie.push(name);//+"-"+c)
            }
            //console.log(JSON.stringify( kategorie))
            //kategorie = [...new Set(kategorie)].sort((a,b)=>a-b);
            //kategorie.forEach((v,i)=>{kategorie[i]=roles[parseInt(v)]})
            //console.log(kategorie)



    const kategoriaKolor = {};
    kategorie.forEach((key,c)=>{
        let val = pallete[c];
        kategoriaKolor[key]=val;
    });
    kategoriaKolor["Inne"]="#000040";

    //console.log(kategoriaKolor)
	// 3. Inicjalizacja mapy
	map = L.map('map').setView([52.0, 19.0], 6);
	
	// 4. Dodanie warstwy OpenStreetMap
	L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
	    attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
	}).addTo(map);

	
	// ***********************************************
	// NOWE KROKI DLA FILTRA: Grupy Warstw
	// ***********************************************

	// 5. Inicjalizacja Grup Warstw (Layer Groups) dla każdej kategorii
	
	Object.keys(kategoriaKolor).forEach(kategoria => {
	    // Każda grupa jest domyślnie dodawana do mapy (czyli jest widoczna)
	    //console.log(0,kategoria)
	    //qqqqqqqqqqqqqqqqqqqqqqqqqq
	    kategorieGrupy[kategoria] = L.layerGroup().addTo(map);
	});
	// Upewnienie się, że grupa 'Inne' istnieje
	if (!kategorieGrupy["Inne"]) {kategorieGrupy["Inne"] = L.layerGroup().addTo(map);}


	// 6. Funkcja do tworzenia markera z widocznym opisem (tabliczka)
	const utworzCustomMarker=(dane) =>{
	    //console.log(dane)
	    const kategoria = dane.kategoria;
	    //console.log("kategoria=",kategoria,dane.role)
	    const kolor = kategoriaKolor[kategoria] || kategoriaKolor["Inne"];
	    
	    // Określenie, do której grupy warstw należy ten marker
	    const grupa = kategorieGrupy[kategoria] || kategorieGrupy["Inne"];
	
	    // Tworzenie elementu DIV dla markera (widoczna 'tabliczka')
	    const iconDiv = document.createElement('div');
	    iconDiv.className = 'custom-marker';
	    iconDiv.style.borderColor = dane.txcolor;
	    iconDiv.style.backgroundColor = dane.bgcolor;
	    iconDiv.style.color = dane.txcolor;
	    iconDiv.textContent = dane.opis;
	
	    // Ustawienie koloru "szpikulca" (dla CSS)
	    const styleSheet = document.createElement("style");
	    styleSheet.innerHTML = `.custom-marker[data-color="${kolor}"]::after { border-top-color: ${kolor}; }`;
	    document.head.appendChild(styleSheet);
	    iconDiv.setAttribute('data-color', kolor);
	
	    // Utworzenie niestandardowej ikony Leaflet
	    const customIcon = L.divIcon({
	        html: iconDiv,
	        className: 'custom-icon',
	        iconSize: [0, 0],
	        iconAnchor: [0, 0]
	    });
	    
	    // Utworzenie markera i dodanie go do ODPOWIEDNIEJ GRUPY
	    const marker = L.marker([dane.lat, dane.lon], { 
	        icon: customIcon,
	        iconAnchor: [0, 0],
            originalDescription: dane.opis+" "+dane.long+" "+dane.id+" "+dane.doba,// + " " + dane.kategoria, // dla wyszukiwania
	        draggable: true,
            kategoria: dane.kategoria // Zapisz kategorię, aby wiedzieć, do której grupy należy
	    }).addTo(grupa); // <--- Zmiana: dodajemy do grupy, nie bezpośrednio do mapy
        wszystkieMarkery.push(marker);
	    
	
	    // Dodanie okna pop-up po kliknięciu
	    const popupContent = `
	        <div style="font-family: sans-serif;">
	            <h4 style="margin: 0 0 5px; color: ${kolor};">${dane.opis} <n>[${dane.km}km]</n></h4>
	            <p style="margin: 0; font-size: 14px;">${dane.szczegolowy_opis}</p>
	            <em>${dane.id}<b>  [${dane.kategoria}]</b><br /> hop:${dane.hop}, SNR=${dane.snr}dB</em>
                <br />${dane.time}
	        </div>
	    `;
	//<em>Role: <b>${dane.kategoria}</b>, hop:${dane.hop}<br />${dane.id}, SNR=${dane.snr}dB</em>
	    marker.bindPopup(popupContent, {
	        offset: L.point(0, -30)
	    });
	
	    // ***********************************************
	    // NOWY KROK: Obsługa zdarzenia po zakończeniu przesuwania
	    // ***********************************************
	    marker.on('moveend', function(e) {
            return
	        const newLatLng = marker.getLatLng();
	        //console.log(`Punkt "${dane.opis}" przesunięto do: Lat ${newLatLng.lat.toFixed(6)}, Lng ${newLatLng.lng.toFixed(6)}`);
	        
	        // Aktualizacja treści pop-upu z nowymi współrzędnymi (opcjonalnie)
	        marker.setPopupContent(popupContent + 
	            `<hr style="margin: 5px 0;">
	            <p style="margin: 0; font-size: 12px; color: #555;">Nowa pozycja:<br>
	            Lat: ${newLatLng.lat.toFixed(6)}<br>
	            Lng: ${newLatLng.lng.toFixed(6)}</p>
	        `).openPopup();
	    });    
	    return marker;
	}


const mapaMAPA=(daneJson)=>{
    // 6. Przetwarzanie danych JSON i dodawanie markerów
    daneJson.forEach(dane => {
        utworzCustomMarker(dane);
    });

    // Opcjonalnie: Dopasowanie widoku mapy do wszystkich markerów
    if (daneJson.length > 0) {
        const bounds = L.latLngBounds(daneJson.map(p => [p.lat, p.lon]));
        map.fitBounds(bounds, { padding: [50, 50] });
    } 
}

// 8. Utworzenie niestandardowego kontrolera dla filtra
const FilterControl = L.Control.extend({
    options: {
        position: 'topright' // Umieść kontroler w prawym górnym rogu
    },

    onAdd: function (map) {
        // Utworzenie głównego kontenera DIV
        const container = L.DomUtil.create('div', 'filter-control leaflet-bar');
        
        // Zbudowanie HTML dla listy checkboxów
        let htmlContent = `<h4>Node: <span id="licznik">${Object.keys(meshtNODE).length}</span></h4>`;
        
        Object.keys(kategorieGrupy).forEach((kategoria,i) => {
            const id = 'filter-' + kategoria.toLowerCase();
            const kolor = kategoriaKolor[kategoria] || kategoriaKolor["Inne"];

            htmlContent += `
                <label for="${id}" style="color: ${kolor};" title="${kategoria}-${arrKat[i]}" data-cnt="${arrKat[i]}">
                    <input type="checkbox" id="${id}" checked data-kategoria="${kategoria}" data-cnt="${arrKat[i]}">
                    ${kategoria}
                </label>
            `;
        });

        htmlContent += "<button onclick='showOrNot(false)'>Nic</button>";
        htmlContent += "<button onclick='showOrNot(true)'>Wszystko</button>";
        
        //htmlContent += "<button class='btn' onclick='showSearch(\"newer\")'>New</button>";
        //htmlContent += "<button class='btn' onclick='showSearch(\"actual\")'>Actual</button>";
        //htmlContent += "<button class='btn' onclick='showSearch(\"day\")'>24h</button>";
        
        container.innerHTML = htmlContent;

        // Zapobieganie zdarzeniom mapy (przesunięcie, powiększenie) na kontrolerze
        L.DomEvent.disableClickPropagation(container);
        L.DomEvent.disableScrollPropagation(container);

        // 9. Dodanie logiki obsługi zdarzeń
        container.addEventListener('change', (e) => {
            if (e.target.type === 'checkbox') {
                const kategoria = e.target.getAttribute('data-kategoria');
                const grupa = kategorieGrupy[kategoria];
                //console.log(e.target.checked,grupa)
                if (e.target.checked) {
                    // Włącz checkbox: dodaj grupę do mapy
                    map.addLayer(grupa);
                } else {
                    // Wyłącz checkbox: usuń grupę z mapy
                    map.removeLayer(grupa);
                }
            }
            policzWidocznePunkty();
        });

        return container;
    }
});

// 10. Dodanie kontrolera filtra do mapy
      new FilterControl().addTo(map);

            let nodeJson = convert2Dat(meshtNODE);
            daneJson = nodeJson;
            //console.log(nodeJson);
            
            //console.log(daneJson)
            mapaMAPA(nodeJson);
            /*let aless = document.querySelectorAll("div.filter-control label");
            console.log(aless);
            [...aless].forEach((c)=>{
            })*/









// ***********************************************
// NOWA FUNKCJA: Liczenie widocznych punktów
// ***********************************************

const policzWidocznePunkty=()=> {
    // 1. Pobranie aktualnych granic widocznego obszaru mapy
    const bounds = map.getBounds();
    //console.log(bounds)
    let licznik = 0;
    const widocznePunkty = [];
    
    // Lista wszystkich grup, które są AKTYWNE na mapie
    const aktywneGrupy = Object.values(kategorieGrupy).filter(grupa => map.hasLayer(grupa));
    //console.log(aktywneGrupy.length)
    // 2. Iteracja przez aktywne grupy markerów
    aktywneGrupy.forEach((grupa,i) => {
        // Iteracja przez markery wewnątrz danej grupy
        //console.log(i,grupa)
        grupa.eachLayer(marker => {
            //console.log(marker)
            // 3. Pobranie współrzędnych markera
            const latlng = marker.getLatLng();

            // 4. Sprawdzenie, czy marker znajduje się w granicach
            if (bounds.contains(latlng)) {
                licznik++;
                // Zakładamy, że oryginalne dane (opis) są przechowywane w opcjach markera
                // W Leaflet nie ma to automatycznie, musimy to dodać.
                // Ponieważ dane oryginalne są w zmiennej 'daneJson', użyjemy uproszczonej logiki
                // zakładającej, że marker ma atrybut 'opis'
                //console.log(marker.options.icon.options.html)
                //const opis = marker.options.icon.options.html.match(/<div.*?>(.*?)<\/div>/)[1];
                const opis = marker.options.icon.options.html.textContent //match(/<div.*?>(.*?)<\/div>/)//[1];
                //?????????????????????????????????????????????????????/
                //console.log("000000000000000000=",opis)
                widocznePunkty.push(opis);
            }
        });
    });

    // Wyświetlenie wyniku
    const wynik = `Na mapie widoczne są ${licznik} punkty.`;
    const szczegoly = licznik > 0 ? `Widoczne punkty: ${widocznePunkty.join(', ')}` : '';
    $("#licznik").textContent = licznik
    //alert(`${wynik}\n${szczegoly}`);
	    
	    //console.log(wynik);
	    //console.log(szczegoly);
	}
	
	// ***********************************************
	// NOWY KONTROLER: Przycisk Liczący
	// ***********************************************
	const CountControl = L.Control.extend({
	    options: {
	        position: 'topright' // Umieść obok filtra
	    },
	
	    onAdd: function (map) {
	        const button = L.DomUtil.create('button', 'leaflet-bar count-button');
	        button.innerHTML = 'Policz';
	        button.style.cursor = 'pointer';
	        button.style.padding = '5px 10px';
	        button.style.backgroundColor = '#f4f4f4';
	        button.style.border = '1px solid #ccc';
	        button.style.borderRadius = '3px';
	        button.style.marginTop = '10px'; // Odstęp od filtra
	
	        // Powiązanie zdarzenia kliknięcia z funkcją liczącą
	        L.DomEvent.on(button, 'click', L.DomEvent.stopPropagation)
	                  .on(button, 'click', L.DomEvent.preventDefault)
	                  .on(button, 'click', policzWidocznePunkty);
	        
	        return button;
            
	    }
	});
	
	// Dodanie kontrolera przycisku do mapy
	//????????? new CountControl().addTo(map);




        // ***********************************************
        // NOWY KONTROLER: Blokada Przesuwania
        // ***********************************************
        const DragToggleControl = L.Control.extend({
            options: {
                position: 'topright'    //'topleft' // Umieść w lewym górnym rogu
            },

            onAdd: function (map) {
                // Utworzenie głównego kontenera DIV
                const container = L.DomUtil.create('div', 'drag-toggle-control leaflet-bar');
                const checkboxId = 'drag-toggle-checkbox';

                container.innerHTML = `
                    <div style="padding: 5px; background: white; border-radius: 3px;min-width:126px; color:navy">
                        <input type="checkbox" id="${checkboxId}" checked>
                        <label for="${checkboxId}" style="margin-left: 5px; font-weight: bold;">
                            Przesuw ON
                        </label>
                    </div>
                `;
                
                // Odczytanie elementów
                const checkbox = container.querySelector(`#${checkboxId}`);
                const label = container.querySelector(`label[for="${checkboxId}"]`);

                // Zapobieganie zdarzeniom mapy
                L.DomEvent.disableClickPropagation(container);
                L.DomEvent.disableScrollPropagation(container);

                // Dodanie logiki obsługi zdarzeń
                L.DomEvent.on(checkbox, 'change', function() {
                    const jestWlaczone = this.checked;
                    
                    // 1. Zmiana etykiety
                    label.textContent = jestWlaczone ? 'Przesuw  ON' : 'Przesuw OFF';
                    
                    // 2. Iteracja po wszystkich markerach i zmiana ich stanu
                    //console.log(wszystkieMarkery.length)
                    wszystkieMarkery.forEach(marker => {
                        //console.log(marker.dragging)
                        if (jestWlaczone) {
                            if (marker.dragging) marker.dragging.enable();
                        } else {
                            if (marker.dragging) marker.dragging.disable();
                        }
                    });

                    // 3. Opcjonalnie: Wyświetlenie komunikatu
                    //console.log(`Przesuwanie markerów: ${jestWlaczone ? 'WŁĄCZONE' : 'WYŁĄCZONE'}`);
                });

                return container;
            }
        });

        // Dodanie kontrolera do mapy
        new DragToggleControl().addTo(map);



        /**
         * Zaznacza na mapie wielokąt (polygon) na podstawie podanych współrzędnych.
         * @param {Array<Array<number>>} coords Tablica wierzchołków [[lat1, lon1], [lat2, lon2], ...]
         * @param {L.Map} map Obiekt mapy Leaflet.
         */
        function zaznaczObszarPolygon(coords, map) {
            const stylObszaru = {
                // Styl linii granicznej
                color: '#0078FF',     // Kolor linii (niebieski)
                weight: 3,            // Grubość linii
                opacity: 0.8,         // Krycie linii (półprzezroczysta)
                
                // Styl wypełnienia (przezroczysty)
                fillColor: '#0078FF', // Kolor wypełnienia (niebieski)
                fillOpacity: 0.3      // KLUCZ: Przezroczystość wypełnienia (0.0 to całkowita przezroczystość, 1.0 to pełne krycie)
            };

            // Tworzenie obiektu L.Polygon i dodawanie go do mapy
            const obszar = L.polygon(coords, stylObszaru).addTo(map);

                                    // ***********************************************
                                        // DODANIE TEKSTU PRZY POMOCY TOOLTIP
                                        // ***********************************************
                                        const bounds = obszar.getBounds();
                                        // Pobranie współrzędnych północno-zachodnich (najwyższa lat, najniższa lng)
                                        const topLeft = bounds.getNorthWest();
                                        const kotwica = L.marker(topLeft, { opacity: 0.0, clickable: false }).addTo(map);
                                        const przesuniecie = L.point(10, 50); // 10px w prawo (X), 5px w dół (Y)
                                        kotwica.bindTooltip("Nody bez lokalizacji: "+fakeGeo, {
                                            permanent: true,       // Tekst jest stale widoczny
                                            direction: 'top',      // Tekst pojawia się nad kotwicą
                                            offset: przesuniecie,  // Przesuń tekst nieco w prawo i w dół od granicy poligonu
                                            className: 'polygon-label-top-left fakeGeo' // Własna klasa CSS
                                        }).openTooltip();
                                        /*obszar.bindTooltip("Nody bez lokalizacji", {
                                            permanent: true,       // Tekst jest stale widoczny (nie tylko po najechaniu)
                                            direction: 'top',   // Tekst jest wyśrodkowany wewnątrz poligonu
                                            className: 'polygon-label' // Klasa CSS do ewentualnego ostylowania
                                        }).openTooltip();*/
                                                                          


            // Opcjonalnie: dopasowanie widoku mapy do zaznaczonego obszaru
            //map.fitBounds(obszar.getBounds());
            
            return obszar;
        }

        // Przykład użycia (zaznaczenie centrum Warszawy)
        const wierzcholkiWarszawy = [
            [53.25, 14.00],
            [53.20, 14.05],
            [53.22, 14.10],
            [53.26, 14.08]
        ];
        
        const wierzcholkiINNE = [
            [53.30, 14.12],
            [52.88, 14.12],
            [52.88, 15.38],
            [53.30, 15.38],
        ];

        const zaznaczINNE=()=>{
            zaznaczObszarPolygon(wierzcholkiINNE, map);
        }

        setTimeout(()=>{zaznaczINNE()},500)

        //iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii
        //iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii
        //iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii
        let infoINFO = await runINFO();
        //console.log(infoINFO);
        let aktualizacja= "<p><b>Aktualizacja:<br />"+infoINFO.aktualizacja+"</b></p>"
        //$("#info").innerHTML = JSON.stringify(infoINFO,null,4);
        let arr = [];
        for (let key in infoINFO.procent){
            let val = infoINFO.procent[key];
            //console.log(key,val);
            arr.push(`<tr><td>${key}</td><td>${val}</td></tr>`);
        }
        let table = arr.join("");
        $("#info").innerHTML += aktualizacja+"<p>Udział % pakietów</p><table>"+table+"</table>"









// ***********************************************
// NOWY KONTROLER: Wyszukiwarka Punktów
// ***********************************************
const SearchControl = L.Control.extend({
    options: {
        position: 'topright' // topleft topright Umieść w lewym górnym rogu, pod przełącznikiem przesuwania
    },

    onAdd: function (map) {
        // Główny kontener
        const container = L.DomUtil.create('div', 'search-control leaflet-bar');
        
        // Pole wprowadzania tekstu
        container.innerHTML = `
            <input type="text" id="search-input" placeholder="Wyszukaj punkt..." 
                   style="padding: 5px; border: 1px solid #ccc; border-radius: 3px; width:126px; font-size: 14px;">
            <button id="clear-search" 
                    style="position: absolute; right: 0; top: 0; height: 100%; width: 15px; 
                           border: none; background: none; cursor: pointer; color: #888; 
                           font-size: 16px; font-weight: bold; padding: 0; margin:0;min-width: 2em;"
                    title="Wyczyść wyszukiwanie">
                &times; 
            </button>
        `;
        
        const input = container.querySelector('#search-input');
        const clearButton = container.querySelector('#clear-search');

        // Zapobieganie zdarzeniom mapy
        L.DomEvent.disableClickPropagation(container);
        L.DomEvent.disableScrollPropagation(container);

        // Dodanie logiki obsługi zdarzeń: filtrowanie przy każdym naciśnięciu klawisza
        L.DomEvent.on(input, 'keyup', function() {
            filtrMarkery(this.value.toLowerCase());
            clearButton.style.display = this.value.length > 0 ? 'block' : 'none';
        });
        // Logika kasowania
        L.DomEvent.on(clearButton, 'click', function() {
            input.value = ''; // Wyzerowanie wartości pola
            filtrMarkery(''); // Wywołanie filtru z pustym ciągiem (pokaż wszystko)
            this.style.display = 'none'; // Ukrycie przycisku
            input.focus(); // Ustawienie kursora w polu
        });
        
        // Ukryj przycisk na początku
        clearButton.style.display = 'none';

        return container;
    }
});

// Dodanie kontrolera wyszukiwania do mapy
new SearchControl().addTo(map);


// ***********************************************
// NOWA FUNKCJA: Logika Filtrowania
// ***********************************************
function filtrMarkery(searchText) {
    let znalezionePunkty = 0;

    // Iterujemy po wszystkich globalnie zapisanych markerach
    wszystkieMarkery.forEach(marker => {
        // Odczytujemy oryginalny opis (zgodnie z wcześniej wprowadzonym ulepszeniem)
        const opis = marker.options.originalDescription.toLowerCase();
        console.log(opis)
        
        // Sprawdzenie, czy opis zawiera tekst wyszukiwania
        if (opis.includes(searchText)) {
            // Pokaż marker
            // WAŻNE: W Leaflet do ukrycia markera najlepiej jest go usunąć z mapy
            // a do pokazania go ponownie dodać
            if (!map.hasLayer(marker)) {
                // Musimy sprawdzić, czy jego grupa warstw jest AKTYWNA
                // W tym celu potrzebujemy łatwego dostępu do grupy markera.
                // Uprościmy to, zakładając, że jeśli marker jest w tablicy, to jego grupa została dodana.
                // Najprościej: dodaj marker bezpośrednio, jeśli jest widoczny i jego grupa jest aktywna.
                
                // UWAGA: Dla uproszczenia, usuniemy go i dodamy do jego grupy.
                const kategoria = marker.options.kategoria || "Inne"; // Nowa opcja! Patrz Krok 3
                const grupa = kategorieGrupy[kategoria] || kategorieGrupy["Inne"];

                // Sprawdź, czy cała grupa jest widoczna (czyli czy checkbox w filtrze jest zaznaczony)
                if (map.hasLayer(grupa)) {
                    marker.addTo(grupa);
                    znalezionePunkty++;
                }

            } else {
                 znalezionePunkty++;
            }
        } else {
            // Ukryj marker
            if (map.hasLayer(marker)) {
                marker.remove();
            }
        }
    });

    console.log(`Znaleziono ${znalezionePunkty} punktów pasujących do frazy "${searchText}".`);
    $("#licznik").textContent = Object.keys(znalezionePunkty).length;
    //setTimeout(policzWidocznePunkty,500);
    
}




        // ***********************************************
        // NOWY KONTROLER: Sortowanie/Filtrowanie wg Daty
        // ***********************************************
        const SortControl = L.Control.extend({
            options: {
                position: 'topright' //  topleft Umieść w lewym górnym rogu
            },

            onAdd: function (map) {
                const container = L.DomUtil.create('div', 'sort-control leaflet-bar');
                
                container.innerHTML = `
                    <select id="sort-select" style="width:138px;padding: 5px; border: 1px solid #ccc; border-radius: 3px; font-size: 14px; margin-left: 5px;">
                        <option value="none">Aktywne od...</option>
                        <option value="1">6 godzin</option>
                        <option value="5">12 godzin</option>
                        <option value="24">24 godziny</option>
                        <option value="72">3 doby</option>
                        <option value="0">Wszystko</option>
                    </select>
                `;
                
                const select = container.querySelector('#sort-select');

                L.DomEvent.disableClickPropagation(container);
                L.DomEvent.disableScrollPropagation(container);

                // Wywołanie funkcji sortującej przy zmianie wyboru
                L.DomEvent.on(select, 'change', function() {
                    sortujPunkty(this.value);
                });

                return container;
            }
        });

        // Dodanie kontrolera sortowania do mapy
        new SortControl().addTo(map);

        /**
 * Usuwa wszystkie markery z mapy, sortuje daneJson i dodaje markery ponownie.
 * @param {string} kryterium 'najnowsze', 'najstarsze' lub 'none'.
 */
function sortujPunkty(kryterium) {
    // 1. Czyszczenie mapy (usuwanie wszystkich markerów z wszystkich grup)
    wszystkieMarkery.forEach(marker => marker.remove());
    wszystkieMarkery.length = 0; // Opróżnienie globalnej tablicy markerów
    
    // Upewnij się, że grupy są puste po usunięciu
    Object.values(kategorieGrupy).forEach(grupa => grupa.clearLayers());


    let posortowaneDane = [...daneJson]; // Tworzenie kopii danych do sortowania
//let teraz = (new Date()).getTime();
let delta = parseInt(kryterium);

if (delta > 0) posortowaneDane = posortowaneDane.filter((a) => a.data_dodania<delta);
//console.log(delta,posortowaneDane);
$("#licznik").textContent = posortowaneDane.length
/*
    // 2. Sortowanie danych
    if (kryterium === 'najnowsze') {
        // Sortowanie malejące (najnowsze daty na górze)
        posortowaneDane.sort((a, b) => new Date(b.data_dodania) - new Date(a.data_dodania));
        console.log("Sortowanie: Najnowsze");
    } else if (kryterium === 'najstarsze') {
        // Sortowanie rosnące (najstarsze daty na górze)
        posortowaneDane.sort((a, b) => new Date(a.data_dodania) - new Date(b.data_dodania));
        console.log("Sortowanie: Najstarsze");
    } else {
        // Brak sortowania, powrót do kolejności oryginalnej (lub po prostu dodanie bez zmian)
        posortowaneDane = daneJson;
        console.log("Sortowanie wyłączone.");
    }
*/
    // 3. Ponowne dodawanie markerów w nowej, posortowanej kolejności
    posortowaneDane.forEach(dane => {
        // Sprawdź, czy marker ma zostać dodany do aktywnej grupy (zgodnie z filtrem kategorii)
        const grupa = kategorieGrupy[dane.kategoria] || kategorieGrupy["Inne"];
        
        // Ponowne użycie funkcji tworzenia markera
        const marker = utworzCustomMarker(dane); // Funkcja utworzCustomMarker dodaje marker do 'wszystkieMarkery' i jego grupy

        // UWAGA: Trzeba upewnić się, że marker jest widoczny, jeśli jego grupa jest aktywna
        if (map.hasLayer(grupa)) {
             // Jeśli grupa jest aktywna, nic nie robimy - marker został dodany do mapy w utworzCustomMarker.
        } else {
             // Jeśli grupa jest nieaktywna (checkbox wyłączony), usuwamy marker z mapy.
             // (Choć technicznie jest w grupie, grupa nie jest na mapie, więc jest OK)
             marker.remove();
        }
    });

    // 4. Po sortowaniu warto wywołać funkcję filtrującą z aktualną frazą,
    // aby zachować filtr wyszukiwania, jeśli był aktywny.
    const searchInput = document.getElementById('search-input');
    if (searchInput && searchInput.value) {
        filtrMarkery(searchInput.value.toLowerCase());
    }
}


});
// EOF domready async --------------------------------------------
// EOF domready async --------------------------------------------
// EOF domready async --------------------------------------------




</script>
</body>
</html>
